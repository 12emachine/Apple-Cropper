<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Image Cropper</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- PWA Meta Tags -->
    <link rel="manifest" href="/Apple-Cropper-/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#4f46e5">
    <link rel="apple-touch-icon" href="/Apple-Cropper-/icon-192.png">
    <!-- Splash Screens -->
    <link rel="apple-touch-startup-image" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3)" href="/Apple-Cropper-/splash-1170x2532.png">
    <link rel="apple-touch-startup-image" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)" href="/Apple-Cropper-/splash-2048x2732.png">
    <style>
        body { font-family: 'Inter', sans-serif; min-height: 100vh; margin: 0; background-color: #f3f4f6; }
        canvas {
            display: block;
            background: #fff;
            border: 2px dashed #d1d5db;
            max-width: 100%;
            height: auto;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            cursor: crosshair;
            touch-action: none; /* Prevent iOS zoom/scroll */
        }
        .hidden-input { display: none; }
    </style>
</head>
<body class="p-4 flex flex-col items-center justify-center">
    <div class="w-full max-w-2xl bg-white p-6 md:p-8 rounded-2xl shadow-2xl space-y-6">
        <h1 class="text-3xl font-bold text-gray-800 text-center">
            Mobile Image Cropper
        </h1>
        <p class="text-center text-gray-500 mb-6">
            Upload, define a crop area by dragging on the image, and download the result.
        </p>
        <!-- Image Upload and Controls -->
        <div class="flex flex-col sm:flex-row gap-4">
            <label for="imageUpload" class="flex-1 cursor-pointer bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-200 text-center shadow-md">
                Select Image
            </label>
            <input type="file" id="imageUpload" class="hidden-input" accept="image/*">
            <button id="cropButton" disabled class="flex-1 bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-6 rounded-lg transition duration-200 disabled:opacity-50 shadow-md">
                Crop Selection
            </button>
            <button id="downloadButton" disabled class="flex-1 bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-3 px-6 rounded-lg transition duration-200 disabled:opacity-50 shadow-md">
                Download Cropped
            </button>
        </div>
        <!-- Canvas Area -->
        <div id="canvasContainer" class="w-full relative min-h-64 flex items-center justify-center rounded-xl bg-gray-100 p-2">
            <p id="placeholderText" class="text-gray-400 text-lg absolute">Upload an image to start cropping...</p>
            <canvas id="imageCanvas"></canvas>
        </div>
        <!-- Notification Box -->
        <div id="notification" class="hidden p-3 bg-red-100 border border-red-400 text-red-700 rounded-lg" role="alert"></div>
    </div>
    <script>
        // Global Constants
        const NOTIFICATION_DURATION = 3000;
        const MIN_CROP_SIZE = 5;

        // DOM Elements
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        const uploadInput = document.getElementById('imageUpload');
        const cropButton = document.getElementById('cropButton');
        const downloadButton = document.getElementById('downloadButton');
        const notificationBox = document.getElementById('notification');
        const placeholderText = document.getElementById('placeholderText');
        const canvasContainer = document.getElementById('canvasContainer');

        // State Variables
        let originalImage = null;
        let isDragging = false;
        let cropRect = { startX: 0, startY: 0, endX: 0, endY: 0 };
        let imageToCanvasRatio = 1;

        // Utility Functions
        function canvasToImageCoords(x, y) {
            return {
                x: x * imageToCanvasRatio,
                y: y * imageToCanvasRatio
            };
        }

        function showNotification(message, type = 'error') {
            notificationBox.textContent = message;
            notificationBox.className = `p-3 border rounded-lg ${type === 'success' ? 'bg-green-100 border-green-400 text-green-700' : 'bg-red-100 border-red-400 text-red-700'}`;
            notificationBox.classList.remove('hidden');
            setTimeout(() => notificationBox.classList.add('hidden'), NOTIFICATION_DURATION);
        }

        // Drawing and Rendering
        function redrawCanvas() {
            if (!originalImage) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const sx = Math.min(cropRect.startX, cropRect.endX);
            const sy = Math.min(cropRect.startY, cropRect.endY);
            const width = Math.abs(cropRect.startX - cropRect.endX);
            const height = Math.abs(cropRect.startY - cropRect.endY);
            ctx.clearRect(sx, sy, width, height);
            ctx.save();
            ctx.beginPath();
            ctx.rect(sx, sy, width, height);
            ctx.clip();
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
            ctx.restore();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.strokeRect(sx, sy, width, height);
        }

        function setupCanvas(image) {
            const containerWidth = canvasContainer.clientWidth;
            const containerHeight = Math.min(window.innerHeight * 0.8, 600);
            canvasContainer.style.height = `${containerHeight}px`;
            const imageAspectRatio = image.width / image.height;
            let canvasWidth = containerWidth;
            let canvasHeight = containerWidth / imageAspectRatio;
            if (canvasHeight > containerHeight) {
                canvasHeight = containerHeight;
                canvasWidth = containerHeight * imageAspectRatio;
            }
            canvas.width = Math.floor(canvasWidth);
            canvas.height = Math.floor(canvasHeight);
            imageToCanvasRatio = image.width / canvas.width;
            cropRect = { startX: 0, startY: 0, endX: canvas.width, endY: canvas.height };
            isDragging = false;
            placeholderText.classList.add('hidden');
            canvas.style.display = 'block';
            redrawCanvas();
            cropButton.disabled = false;
            downloadButton.disabled = false;
        }

        // Event Handlers
        uploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file || !file.type.startsWith('image/')) {
                showNotification('Please select a valid image file.');
                originalImage = null;
                cropButton.disabled = true;
                downloadButton.disabled = true;
                placeholderText.classList.remove('hidden');
                canvas.style.display = 'none';
                return;
            }
            if (file.size > 5 * 1024 * 1024) {
                showNotification('Image is too large. Please select a file under 5MB.');
                return;
            }
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    setupCanvas(originalImage);
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        function getCanvasPos(event) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        const startDrag = (event) => {
            if (!originalImage) return;
            if (event.type.startsWith('touch')) {
                event.preventDefault();
            }
            isDragging = true;
            const pos = getCanvasPos(event);
            cropRect.startX = pos.x;
            cropRect.startY = pos.y;
            cropRect.endX = pos.x;
            cropRect.endY = pos.y;
            redrawCanvas();
        };

        const drag = (event) => {
            if (!isDragging || !originalImage) return;
            if (event.type.startsWith('touch')) {
                event.preventDefault();
            }
            const pos = getCanvasPos(event);
            cropRect.endX = pos.x;
            cropRect.endY = pos.y;
            redrawCanvas();
        };

        const stopDrag = () => {
            if (!originalImage) return;
            isDragging = false;
            const sx = Math.min(cropRect.startX, cropRect.endX);
            const sy = Math.min(cropRect.startY, cropRect.endY);
            const ex = Math.max(cropRect.startX, cropRect.endX);
            const ey = Math.max(cropRect.startY, cropRect.endY);
            cropRect = { startX: sx, startY: sy, endX: ex, endY: ey };
        };

        // Primary Actions
        cropButton.addEventListener('click', () => {
            if (!originalImage) {
                showNotification('Please load an image first.');
                return;
            }
            const width = cropRect.endX - cropRect.startX;
            const height = cropRect.endY - cropRect.startY;
            if (width < MIN_CROP_SIZE || height < MIN_CROP_SIZE) {
                showNotification('The selection is too small. Please select a larger area.', 'error');
                return;
            }
            const sourceStart = canvasToImageCoords(cropRect.startX, cropRect.startY);
            const sourceEnd = canvasToImageCoords(cropRect.endX, cropRect.endY);
            const sourceWidth = sourceEnd.x - sourceStart.x;
            const sourceHeight = sourceEnd.y - sourceStart.y;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = sourceWidth;
            tempCanvas.height = sourceHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(
                originalImage,
                sourceStart.x, sourceStart.y, sourceWidth, sourceHeight,
                0, 0, sourceWidth, sourceHeight
            );
            originalImage = new Image();
            originalImage.onload = () => {
                setupCanvas(originalImage);
                showNotification('Image successfully cropped!', 'success');
            };
            originalImage.src = tempCanvas.toDataURL('image/png');
            cropRect = { startX: 0, startY: 0, endX: canvas.width, endY: canvas.height };
        });

        downloadButton.addEventListener('click', () => {
            if (!originalImage) {
                showNotification('Nothing to download. Please load and crop an image first.');
                return;
            }
            const dataURL = canvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'cropped_image_' + Date.now() + '.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            showNotification('Download initiated.', 'success');
        });

        // Initialize and Attach Event Listeners
        canvas.addEventListener('mousedown', startDrag);
        canvas.addEventListener('mousemove', drag);
        canvas.addEventListener('mouseup', stopDrag);
        canvas.addEventListener('mouseout', stopDrag);
        canvas.addEventListener('touchstart', startDrag);
        canvas.addEventListener('touchmove', drag);
        canvas.addEventListener('touchend', stopDrag);
        canvas.addEventListener('touchcancel', stopDrag);
        canvas.style.display = 'none';
        window.addEventListener('resize', () => {
            if (originalImage) {
                setupCanvas(originalImage);
            }
        });

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/Apple-Cropper-/sw.js')
                    .then((registration) => {
                        console.log('Service Worker registered:', registration);
                    })
                    .catch((error) => {
                        console.error('Service Worker registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>
